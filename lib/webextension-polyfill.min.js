(function(global,factory){if(typeof exports==="object"&&typeof module!=="undefined"){factory(module)}else if(typeof define==="function"&&define.amd){define(["module"],factory)}else{var mod={exports:{}};factory(mod);global.browser=mod.exports}})(typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:this,function(module){"use strict";if(typeof browser==="undefined"||Object.getPrototypeOf(browser)!==Object.prototype){const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE="The message port closed before a response was received.";const wrapAPIs=extensionAPIs=>{const apiMetadata={runtime:{onMessage:{addListener:(target,listener,wrappingFunction)=>{target.addListener(listener,wrappingFunction)}}},tabs:{onUpdated:{addListener:(target,listener,wrappingFunction)=>{target.addListener(listener,wrappingFunction)}}}};const wrapObject=(target,wrappers={},metadata={})=>{const cache=Object.create(null);const handlers={get(target,prop,receiver){if(prop==="__esModule"){return target.__esModule}if(prop==="then"){return target.then}if(prop in cache){return cache[prop]}if(!(prop in target)){return undefined}const value=target[prop];if(typeof value==="function"){if(typeof wrappers[prop]==="function"){return cache[prop]=wrappers[prop].call(receiver,target)}else{return cache[prop]=value.bind(target)}}else if(typeof value==="object"&&value!==null&&(metadata[prop]||Object.keys(value).length)){return cache[prop]=wrapObject(value,wrappers[prop],metadata[prop])}return cache[prop]=value},set(target,prop,value,receiver){if(prop in cache){cache[prop]=value}else{target[prop]=value}return true},defineProperty(target,prop,desc){return Reflect.defineProperty(target,prop,desc)},deleteProperty(target,prop){return Reflect.deleteProperty(target,prop)}};return new Proxy(target,handlers)};const wrapMethod=(target,method,wrapper)=>{return new Proxy(method,{apply(targetMethod,thisObj,args){return wrapper.call(thisObj,target,...args)}})};const wrapAsyncFunction=(name,metadata)=>{return function asyncFunctionWrapper(target,...args){return new Promise((resolve,reject)=>{target[name](...args,(...callbackArgs)=>{if(chrome.runtime.lastError){if(chrome.runtime.lastError.message===CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE){resolve()}else{reject(chrome.runtime.lastError)}}else{resolve(...callbackArgs)}})})}};const wrapEventAddListener=(name,metadata)=>{return function eventWrapper(target,...args){const hasListener=args.length===1&&typeof args[0]==="function";if(hasListener){target[name].addListener(args[0])}else{target[name].addListener(...args)}}};const staticWrappers={runtime:{onMessage:wrapEventAddListener("onMessage",apiMetadata.runtime.onMessage),sendMessage:wrapAsyncFunction("sendMessage",{}),get lastError(){return chrome.runtime.lastError}},tabs:{create:wrapAsyncFunction("create",{}),sendMessage:wrapAsyncFunction("sendMessage",{})},storage:{sync:{get:wrapAsyncFunction("get",{}),set:wrapAsyncFunction("set",{}),clear:wrapAsyncFunction("clear",{})}}};return wrapObject(extensionAPIs,staticWrappers,apiMetadata)};if(typeof chrome!=="object"||!chrome||!chrome.runtime||!chrome.runtime.id){throw new Error("This script should only be loaded in a browser extension.")}module.exports=wrapAPIs(chrome)}else{module.exports=browser}});
